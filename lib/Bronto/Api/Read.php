<?php
/**
 * This file was generated by the ConvertToLegacy class in bronto-legacy.
 * The purpose of the conversion was to maintain PSR-0 compliance while
 * the main development focuses on modern styles found in PSR-4.
 *
 * For the original:
 * @see src/Bronto/Api/Read.php
 */

/**
 * An implementing read request builder. The actual request
 * will come in the form of the aggregated iterator.
 *
 * @author Philip Cali <philip.cali@bronto.com>
 */
class Bronto_Api_Read extends Bronto_Object implements Bronto_Api_Request, IteratorAggregate
{
    protected $_method;
    protected $_operation;
    protected $_requestFields;

    /**
     * @param Bronto_Api_Operation $operation
     * @param string $method
     * @param array originalData
     * @param array $requestFields
     */
    public function __construct(Bronto_Api_Operation $operation, $method, array $originalData = array(), array $requestFields = array())
    {
        parent::__construct(array('filter' => new Bronto_Api_Read_Filter($this, array('type' => 'OR'))));
        foreach ($originalData as $field => $value) {
            if ($field === 'filter') {
                $this->_data['filter']->replace($value);
            } else {
                $this->_set($field, $value);
            }
        }
        $this->_method = $method;
        $this->_operation = $operation;
        $this->_requestFields = $requestFields;
    }

    /**
     * @see parent
     * @return string
     */
    public function getMethod()
    {
        return $this->_method;
    }

    /**
     * @see parent
     * @return boolean
     */
    public function hasUpdates()
    {
        return false;
    }

    /**
     * @see parent
     * @return array
     */
    public function getData()
    {
        $data = $this->toArray();
        unset($data['filter']);
        return array_merge(array('filter' => $this->getFilter()->toArray()), $data);
    }

    /**
     * Adds additional white labeled request fields,
     * with default parameters
     *
     * @param array $requestFields
     * @return Bronto_Api_Read
     */
    public function setRequestFields(array $requestFields)
    {
        $this->_requestFields += $requestFields;
        return $this;
    }

    /**
     * @see parent
     *
     * @param string $name
     * @param array $arguments
     * @return mixed
     */
    public function __call($name, $arguments)
    {
        list($prefix, $camelized) = $this->_camelizedValue($name);
        if (array_key_exists($camelized, $this->_requestFields)) {
            return parent::__call($name, $arguments);
        } else {
            $filter = $this->_data['filter'];
            $return = $filter->__call($name, $arguments);
            if ($return == $filter) {
                return $this;
            } else {
                return $return;
            }
        }
    }

    /**
     * Convenience method for setting the page number in a
     * SQL like expression.
     *
     * @param int $offset
     * @return Bronto_Api_Read
     */
    public function offset($value)
    {
        return $this->withPageNumber($value);
    }

    /**
     * Convenience method for setting a limit on certain read
     * results in a SQL like expression.
     * Note: Only works for SOAP function filters that support the size parameter
     *
     * @param int $value
     * @return Bronto_Api_Read
     */
    public function limit($value)
    {
        if ($value < 1000 || $value > 5000) {
            throw new InvalidArgumentException("Read limit must be between 1000 and 5000: $value");
        }
        return $this->withSize($value);
    }

    /**
     * Creates or continues a SQL like filter expression.
     * Supported keywords are:
     *
     * - where
     * - and
     * - or
     *
     * @param string $name
     * @return Bronto_Api_Read_Filter
     * @throws LogicException
     */
    public function __get($name)
    {
        switch ($name) {
        case 'where':
            return $this->getFilter()->open();
        case 'and':
        case 'or':
            return $this->getFilter()->open(strtoupper($name));
        default:
            throw new LogicException("Unsupported query verb $name");
        }
    }

    /**
     * Retrieves the first entry in the aggregated iterator
     *
     * @return Bronto_Api_Object|null
     */
    public function first()
    {
       $firstEntry = null;
       foreach ($this as $first) {
          return $first;
       }
       return $firstEntry;
    }

    /**
     * Creates the aggregated iterator that performs the read ops
     *
     * @return Bronto_Api_Read_Pager
     */
    public function getIterator()
    {
        $clonedRequest = new Bronto_Object(array(
            'method' => $this->_method,
            'data' => new Bronto_Object($this->getData())
        ));
        return $this->_operation->createReadPager($clonedRequest);
    }
}
