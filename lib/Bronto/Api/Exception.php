<?php
/**
 * This file was generated by the ConvertToLegacy class in bronto-legacy.
 * The purpose of the conversion was to maintain PSR-0 compliance while
 * the main development focuses on modern styles found in PSR-4.
 *
 * For the original:
 * @see src/Bronto/Api/Exception.php
 */

/**
 * General API exception wrapper and exposes a few convenience
 * methods helpful for debugging.
 *
 * @author Philip Cali <philip.cali@bronto.com>
 */
class Bronto_Api_Exception extends RuntimeException
{
    const UNKNOWN_ERROR = 101;
    const INVALID_TOKEN = 102;
    const INVALID_SESSION_TOKEN = 103;
    const INVALID_ACCESS = 104;
    const INVALID_INPUT_ARRAY = 105;
    const INVALID_PARAMETER = 106;
    const INVALID_REQUEST = 107;
    const SHARD_OFFLINE = 108;
    const SITE_INACTIVE = 109;
    const REQUIRED_FIELDS = 110;
    const UNAUTHORIZED_IP = 111;
    const INVALID_FILTER = 112;
    const READ_ERROR = 113;
    const INVALID_PAGE_SIZE = 115;

    const HTTP_HEADER_ERROR = 98001;
    const NO_XML_DOCUMENT = 98002;
    const INVALID_URL = 98003;
    const CONNECT_ERROR = 98004;
    const WSDL_PARSE_ERROR = 98005;
    const REQUEST_ERROR = 98006;
    const CONNECTION_RESET = 98007;
    const CONNECTION_FAILED = 98008;
    const SERVICE_UNAVAILABLE = 98009;
    const SOAPCLIENT_ERROR = 98010;
    const SERVER_ERROR = 98500;

    private $_tries;
    private $_previous;
    private $_request;
    private $_recoverable = false;
    private static $_recoverables = array(
        self::UNKNOWN_ERROR,
        self::INVALID_SESSION_TOKEN,
        self::SHARD_OFFLINE,
        self::READ_ERROR,
        self::HTTP_HEADER_ERROR,
        self::NO_XML_DOCUMENT,
        self::CONNECT_ERROR,
        self::WSDL_PARSE_ERROR,
        self::CONNECTION_RESET,
        self::CONNECTION_FAILED,
        self::SERVICE_UNAVAILABLE,
        self::SERVER_ERROR,
        self::SOAPCLIENT_ERROR,
    );

    /**
     * @see parent
     * @param string $message
     * @param int code
     * @param Exception $previous
     * @param int tries
     * @param Bronto_Object $request
     */
    public function __construct($message = "", $code = 0, Exception $previous = null, $tries = 0, $request = null)
    {
        if (empty($code)) {
            $parts = explode(':', $message, 2);
            if (is_array($parts)) {
                $parts = array_map('trim', $parts);
                if (is_numeric($parts[0])) {
                    $code = (int) $parts[0];
                    $message = $parts[1];
                }
            }
        }

        if (empty($code)) {
            if (stripos($message, 'Error Fetching http headers') !== false) {
                $code = self::HTTP_HEADER_ERROR;
            } else if (stripos($message, 'looks like we got no XML document') !== false) {
                $code = self::NO_XML_DOCUMENT;
            } else if (stripos($message, 'Could not connect to host') !== false) {
                $code = self::CONNECT_ERROR;
            } else if (stripos($message, 'Parsing WSDL') !== false) {
                $code = self::WSDL_PARSE_ERROR;
            } else if (stripos($message, 'There was an error in your soap request') !== false) {
                $code = self::INVALID_REQUEST;
            } else if (stripos($message, 'Connection reset by peer') !== false) {
                $code = self::CONNECTION_RESET;
            } else if (stripos($message, 'Unable to parse URL') !== false) {
                $code = self::INVALID_URL;
            } else if (stripos($message, 'Service Temporarily Unavailable') !== false) {
                $code = self::SERVICE_UNAVAILABLE;
            } else if (stripos($message, 'Internal Server Error') !== false) {
                $code = self::SERVER_ERROR;
            } else if (stripos($message, 'SoapClient::__doRequest()') !== false) {
                $code = self::SOAPCLIENT_ERROR;
            }
        }

        if (!empty($code)) {
            $message = "{$code}: {$message}";
        }

        if (!empty($tries) && $tries > 1) {
            $message .= " [Tried: {$tries}]";
        }

        $this->_previous = $previous;
        if (version_compare(PHP_VERSION, '5.3.0') >= 0) {
            parent::__construct($message, $code, $previous);
        } else {
            parent::__construct($message, $code);
        }
        $this->_tries = $tries;
        $this->_recoverable = in_array($this->getCode(), self::$_recoverables);
        $this->_request;
    }

    /**
     * Returns the number of attempts made with this request
     *
     * @return int
     */
    public function getAttempts()
    {
        return $this->_tries;
    }

    /**
     * Determines if the exception is recoverable
     *
     * @return boolean
     */
    public function isRecoverable()
    {
        return $this->_recoverable;
    }

    /**
     * The actual request object used by the SoapClient
     *
     * @return Bronto_Object
     */
    public function getRequest()
    {
        return $this->_request;
    }

    /**
     * Determines if the exception is a SPL SoapFault
     *
     * @return boolean
     */
    public function isSoapFault()
    {
        return $this->_previous instanceof SoapFault;
    }

    /**
     * Is this session invalid?
     *
     * @return boolean
     */
    public function isInvalidSession()
    {
        return $this->getCode() == self::INVALID_SESSION_TOKEN;
    }

    /**
     * Is the exception caused by Bronto maintenance?
     *
     * @return boolean
     */
    public function isMaintenance()
    {
        return $this->getCode() == self::SHARD_OFFLINE;
    }

    /**
     * Is the exception caused by general network issues?
     *
     * @return boolean
     */
    public function isNetworkRelated()
    {
        return (
            $this->isMaintenance() ||
            ($this->isSoapFault() && $this->isRecoverable())
        );
    }
}
