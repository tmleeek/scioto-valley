<?php
/**
 * This file was generated by the ConvertToLegacy class in bronto-legacy.
 * The purpose of the conversion was to maintain PSR-0 compliance while
 * the main development focuses on modern styles found in PSR-4.
 *
 * For the original:
 * @see src/Bronto/Api/Write.php
 */


/**
 * The implementing write request builder. The actual request
 * will come in the form of the aggregated iterator.
 *
 * @author Philip Cali <philip.cali@bronto.com>
 */
class Bronto_Api_Write extends Bronto_Object implements Bronto_Api_Request, IteratorAggregate
{
    protected $_method;
    protected $_operation;
    protected $_limit;
    protected $_flusher;
    protected $_acceptablePrefixes;
    protected $_resolvedKey;

    /**
     * @param Bronto_Api_Operation $operation
     * @param string $method
     * @param int $limit
     * @param string $dynamicMethod
     * @param string $resolvedKey
     */
    public function __construct(Bronto_Api_Operation $operation, $method, $limit, $dynamicMethod, $resolvedKey)
    {
        parent::__construct();
        $this->_operation = $operation;
        $this->_method = $method;
        $this->_limit = $limit;
        $this->_resolvedKey = $resolvedKey;

        if ($method == $dynamicMethod) {
            $this->_acceptablePrefixes = array($method);
        } else {
            $this->_acceptablePrefixes = array(
                $dynamicMethod,
                $dynamicMethod . $this->_operation->getTransferType(),
                $dynamicMethod . $this->_operation->getPluralizedType());
            if ($dynamicMethod == 'addOrUpdate') {
                foreach (array('add', 'update') as $write) {
                    $this->_acceptablePrefixes[] = $write;
                    $this->_acceptablePrefixes[] = $write . $this->_operation->getTransferType();
                    $this->_acceptablePrefixes[] = $write . $this->_operation->getPluralizedType();
                }
            }
        }
    }

    /**
     * @see parent
     * @return string
     */
    public function getMethod()
    {
        return $this->_method;
    }

    /**
     * @see parent
     * @return boolean
     */
    public function hasUpdates()
    {
        return true;
    }

    /**
     * @see parent
     * @return array
     */
    public function getData()
    {
        return $this->toArray();
    }

    /**
     * The write key used in the SOAP function.
     *
     * @return string
     */
    public function getKey()
    {
        return $this->_resolvedKey;
    }

    /**
     * Set a callback on the write request that will
     * flush the results when the limit has been reached
     *
     * @param Bronto_Api_Write_Flusher|callable $callback
     * @return Bronto_Api_Write
     */
    public function withFlusher($callback = null)
    {
        $this->_flusher = $callback ? $callback : array($this, '_autoFlusher');
        return $this;
    }

    /**
     * The default flusher that simply checks for errors and throws
     *
     * @param Bronto_Api_Write_Pager $iterator
     * @return void
     */
    protected function _autoFlusher($iterator)
    {
        foreach ($iterator as $entry) {
            $result = $entry->getItem();
            if ($result->getIsError()) {
                throw new Bronto_Api_Exception($result->getErrorString(), $result->getErrorCode());
            }
        }
    }

    /**
     * Convenience that unwraps any Bronto_Object for the transfer
     *
     * @param mixed $object
     * @return mixed
     */
    protected function _unwrapObject($object)
    {
        if (is_array($object)) {
            $object = array_map(array($this, '_unwrapObject'), $object);
        }
        if ($object instanceof Bronto_Object) {
            return $object->toArray();
        }
        return $object;
    }

    /**
     * @see parent
     * @return Bronto_Api_Write
     */
    protected function _set($camelized, $value)
    {
        return parent::_set($camelized, $this->_unwrapObject($value));
    }

    /**
     * Pushing write objects
     *
     * @param mixed $arguments
     * @return Bronto_Api_Write
     */
    public function push($arguments = array())
    {
        if (!is_array($arguments)) {
            $arguments = array($arguments);
        }
        $camelized = $this->_resolvedKey;
        if (!array_key_exists($camelized, $this->_data)) {
            $this->_data[$camelized] = array();
        }
        if (count($this->_data[$camelized]) >= $this->_limit) {
            if ($this->flush()) {
               $this->_data[$camelized] = array();
            } else {
                throw new Bronto_Api_Write_Overflow("Cannot add more $camelized to {$this->_operation->getTransferType()}", $arguments);
            }
        }
        $unwrapped = array_map(array($this, '_unwrapObject'), $arguments);
        $this->_data[$camelized] = array_merge($this->_data[$camelized], $unwrapped);
        return $this;
    }

    /**
     * @see parent
     * @param string $name
     * @param array $arguments
     * @return mixed
     */
    public function __call($name, $arguments)
    {
        if (in_array($name, $this->_acceptablePrefixes)) {
            return $this->push($arguments);
        } else if (preg_match("/^isFullOf{$this->_operation->getPluralizedType()}/", $name)) {
            $camelized = $this->_resolvedKey;
            if (!array_key_exists($camelized, $this->_data)) {
                return false;
            }
            return count($this->_data[$camelized]) >= $this->_limit;
        } else {
            try {
                parent::__call($name, $arguments);
            } catch (BadMethodCallException $bme) {
                throw new BadMethodCallException("For {$this->_method}, supported chains are: " . implode(', ', $this->_acceptablePrefixes), 0, $bme);
            }
        }
    }

    /**
     * Retrieves the first entry in the aggregated iterator
     *
     * @return Bronto_Object['item' => resultItem, 'original' => array]
     */
    public function first()
    {
        $firstEntry = null;
        foreach ($this as $entry) {
            return $entry;
        }
        return $firstEntry;
    }

    /**
     * Flushes any writes using the flusher defined. Will otherwise
     * NOT flush anything. Whether or not it used the flusher is returned
     * as a boolean.
     *
     * @return boolean
     */
    public function flush()
    {
        $flushed = false;
        if (is_callable($this->_flusher)) {
            call_user_func($this->_flusher, $this->getIterator());
            $flushed = true;
        } else if ($this->_flusher instanceof Bronto_Api_Write_Flusher) {
            $this->_flusher->onFlush($this->getIterator());
            $flushed = true;
        }
        if ($flushed) {
            unset($this->_data[$this->_resolvedKey]);
        }
        return $flushed;
    }

    /**
     * Creates the aggregated iterator that performs the write ops.
     *
     * @return Bronto_Api_Write_Pager
     */
    public function getIterator()
    {
        $clonedRequest = new Bronto_Object(array(
            'transferType' => $this->_operation->getTransferType(),
            'key' => $this->_resolvedKey,
            'data' => $this->getData(),
            'method' => $this->_method,
            'updates' => true,
        ));
        return $this->_operation->createWritePager($clonedRequest);
    }
}
