<?php
/**
 * This file was generated by the ConvertToLegacy class in bronto-legacy.
 * The purpose of the conversion was to maintain PSR-0 compliance while
 * the main development focuses on modern styles found in PSR-4.
 *
 * For the original:
 * @see src/Bronto/Api/Read/Filter.php
 */

/**
 * The filter wrapper used in performing SQL like expressions
 *
 * @author Philip Cali <philip.cali@bronto.com>
 */
class Bronto_Api_Read_Filter extends Bronto_Object {
    private $_request;
    private $_opened = false;
    private $_openedType;
    private $_currentField;
    private $_previousField;

    /**
     * @see parent
     * @param Bronto_Api_Read $request
     * @param array $data
     */
    public function __construct($request, array $data = array())
    {
        parent::__construct($data);
        $this->_request = $request;
    }

    /**
     * Declares the SQL expression as open
     *
     * @param string $type
     * @return Filter
     * @throws LogicException
     */
    public function open($type = null)
    {
        if ($this->isOpened()) {
            throw new LogicException("Filter statement was never completed.");
        }
        $this->_opened = true;
        $this->_openedType = $type ? $type : $this->getType();
        return $this;
    }

    /**
     * Declares the SQL expression as closed
     *
     * @return Bronto_Api_Read
     */
    public function close()
    {
        $this->_opened = false;
        if (!is_null($this->_currentField)) {
            $this->_previousField = "{$this->_currentField}";
        }
        $this->_currentField = null;
        return $this->_request;
    }

    /**
     * Whether or not this expression is open
     *
     * @return boolean
     */
    public function isOpened()
    {
        return $this->_opened;
    }

    /**
     * The previous field used in an expression
     *
     * @return string
     */
    public function getPreviousField()
    {
        return $this->_previousField;
    }

    /**
     * Magic getter is used to determine the field name
     *
     * @param string $name
     * @return Filter
     * @throws LogicException
     */
    public function __get($name)
    {
        if ($this->isOpened() && is_null($this->_currentField)) {
            $this->_currentField = $name;
        } else {
            throw new LogicException("Filter statement was not properly opened.");
        }
        return $this;
    }

    /**
     * Magic invocation is used in field names where filter operators
     * are applicable.
     *
     * @param string $name
     * @param array $arguments
     * @return Bronto_Api_Read
     * @throws LogicException
     */
    public function __call($name, $arguments)
    {
        switch ($name) {
        case 'equalTo':
        case 'notEqualTo':
        case 'startsWith':
        case 'endsWith':
        case 'doesNotStartWith':
        case 'doesNotEndWith':
        case 'greaterThan':
        case 'lessThan':
        case 'contains':
        case 'doesNotContain':
        case 'sameYear':
        case 'notSameYear':
        case 'sameDay':
        case 'notSameDay':
        case 'before':
        case 'after':
        case 'beforeOrSameDay':
        case 'afterOrSameDay':
            $this->_protectStatement($name);
            if (!array_key_exists($this->_currentField, $this->_data)) {
                $this->_data[$this->_currentField] = array();
            }
            array_push($this->_data[$this->_currentField], array(
                'operator' => ucfirst($name),
                'value' => $arguments[0]
            ));
            return $this->close();
        case 'in':
            $this->_protectStatement($name);
            $value = is_array($arguments[0]) ? $arguments[0] : $arguments;
            return $this->_set('type', 'OR')->_set($this->_currentField, $value)->close();
        case 'is':
            $this->_protectStatement($name);
            if (is_array($arguments[0])) {
                $value = $arguments[0];
            } else if (count($arguments) > 1) {
                $value = $arguments;
            } else {
                $value = array($arguments[0]);
            }
            return $this->_set($this->_currentField, $value)->close();
        default:
            return parent::__call($name, $arguments);
        }
    }

    /**
     * Protects the state of the expression.
     *
     * @param string $name
     * @return void
     * @throws LogicException
     */
    protected function _protectStatement($name)
    {
        if (is_null($this->_currentField)) {
            if (is_null($this->_previousField)) {
                throw new LogicException("Trying to filter $name on a an empty statement.");
            }
            $this->_currentField = "{$this->_previousField}";
            $this->_set('type', $this->_openedType);
            $this->_previousField = null;
        }
    }
}
