<?php
/**
 * This file was generated by the ConvertToLegacy class in bronto-legacy.
 * The purpose of the conversion was to maintain PSR-0 compliance while
 * the main development focuses on modern styles found in PSR-4.
 *
 * For the original:
 * @see src/Bronto/Api/Read/Pager.php
 */


/**
 * The read pager wraps a Bronto_Api_Read_Transform iterator for every page.
 *
 * @author Philip Cali <philip.cali@bronto.com>
 */
abstract class Bronto_Api_Read_Pager implements Iterator
{
    private $_operation;
    private $_request;
    private $_page;
    private $_startingPoint;
    private $_flatten;

    /**
     * For implementors, determine the current page based on request
     *
     * @param Bronto_Object $request
     * @return mixed
     */
    protected abstract function _getPage($request);

    /**
     * For implementors, determine the next page based on request
     *
     * @param Bronto_Object $request
     * @return void
     */
    protected abstract function _nextPage($request);

    /**
     * For implementors, set the page number on the request
     *
     * @param Bronto_Object $request
     * @param mixed $page
     * @return void
     */
    protected abstract function _setPage($request, $page);

    /**
     * @param Bronto_Api_Operation $operation
     * @param Bronto_Object $request
     */
    public function __construct(Bronto_Api_Operation $operation, Bronto_Object $request)
    {
        $this->_operation = $operation;
        $this->_request = $request;
        $this->_flatten = true;
        $this->_startingPoint = $this->_getPage($request);
    }

    /**
     * Determines if this iterator operates on the Bronto_Api_Read_Transform page.
     *
     * @return Bronto_Api_Read_Pager
     */
    public function flatten()
    {
        $this->_flatten = true;
        return $this;
    }

    /**
     * Determines if this iterator operates on the page.
     *
     * @return Bronto_Api_Read_Pager
     */
    public function paginate()
    {
        $this->_flatten = false;
        return $this;
    }

    /**
     * Gets the current page as a Bronto_Api_Read_Transform iterator
     *
     * @return Bronto_Api_Read_Transform
     */
    public function getCurrentPage()
    {
        if (is_null($this->_page)) {
            $this->rewind();
        }
        return $this->_page;
    }

    /**
     * Creates an internal pager from an API read request
     *
     * @return void
     */
    protected function _currentPage()
    {
        $result = $this->_operation->getApi()->execute($this->_request);
        $this->_page = new Bronto_Api_Read_Transform($this->_operation, $result);
    }

    /**
     * Bumps the read request page and executes
     *
     * @return void
     */
    protected function _next()
    {
        $this->_nextPage($this->_request);
        $this->_currentPage();
    }

    /**
     * @see parent
     * @return boolean
     */
    public function valid()
    {
        if ($this->_flatten && !$this->getCurrentPage()->valid()) {
            $this->_next();
        }
        return $this->getCurrentPage()->valid();
    }

    /**
     * @see parent
     * @return mixed
     */
    public function current()
    {
        return $this->_flatten ? $this->_page->current() : $this->_page;
    }

    /**
     * @see parent
     * @return scalar
     */
    public function key()
    {
        return $this->_flatten ? $this->_page->key() : $this->_operation->getPage($this->_request);
    }

    /**
     * @see parent
     * @return void
     */
    public function next()
    {
        if ($this->_flatten) {
            $this->_page->next();
        } else {
            $this->_next();
        }
    }

    /**
     * @see parent
     * @return void
     */
    public function rewind()
    {
        $this->_setPage($this->_request, $this->_startingPoint);
        $this->_currentPage();
    }

    /**
     * Loads this entire pager into a memory hashtable
     *
     * @return array
     */
    public function toArray()
    {
        if (function_exists('iterator_to_array')) {
            return iterator_to_array($this->getCurrentPage(), true);
        } else {
            $hashTable = array();
            foreach ($this->getCurrentPage() as $id => $object) {
                $hashTable[$id] = $object;
            }
            return $hashTable;
        }
    }
}
