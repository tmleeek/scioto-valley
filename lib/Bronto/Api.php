<?php
/**
 * This file was generated by the ConvertToLegacy class in bronto-legacy.
 * The purpose of the conversion was to maintain PSR-0 compliance while
 * the main development focuses on modern styles found in PSR-4.
 *
 * For the original:
 * @see src/Bronto/Api.php
 */


/**
 * Library entry point and complete wrapper around the SPL SoapClient.
 *
 * @author Philip Cali <philip.cali@bronto.com>
 */
class Bronto_Api
{
    const BASE_URI = 'http://api.bronto.com/v4';
    private $_options;
    private $_token;
    private $_sessionId;
    private $_soapClient;
    private $_authenticated = false;

    /**
     * @param string $token
     * @param array|Options (Optional)
     */
    public function __construct($token, $options = null)
    {
        $this->_token = $token;
        if (is_null($options)) {
            $this->_options = new Bronto_Api_Options();
        } else if (is_array($options)) {
            $this->_options = new Bronto_Api_Options($options);
        } else if ($options instanceof Bronto_Api_Options) {
            $this->_options = $options;
        } else {
            throw new InvalidArgumentException(sprintf('$options must either be an array or Bronto_Api_Options: %s given', $options));
        }
    }

    /**
     * Authenticates the SoapClient
     *
     * @return string
     */
    public function login()
    {
        if (!empty($this->_soapClient)) {
            $this->_soapClient = null;
        }
        $this->setSessionId($this->getSoapClient()->login(array('apiToken' => $this->_token))->return);
        $this->_options->safeObserver()->each(array($this, 'handleLogin'));
        return $this->_sessionId;
    }

    /**
     * If an existing session ID is available, register it with the client
     *
     * @param string $sessionId
     * @return Api
     */
    public function setSessionId($sessionId)
    {
        $this->getSoapClient()->__setSoapHeaders(array(new SoapHeader(self::BASE_URI, 'sessionHeader', array('sessionId' => $sessionId))));
        $this->_sessionId = $sessionId;
        $this->_authenticated = true;
        return $this;
    }

    /**
     * Executes an API request that have at least the following information:
     *
     * - method: string method if the SOAP function
     * - data: data container for the SOAP function
     *
     * @param Object $request
     * @return stdClass
     */
    public function execute(Bronto_Object $request)
    {
        $tries = 0;
        $maxTries = $this->_options->getRetries();
        $method = $request->getMethod();
        $data = $request->getData();
        if ($data instanceof Bronto_Object) {
            $data = $data->toArray();
        }
        do {
            try {
                if (!$this->isAuthenticated()) {
                    $this->login();
                }
                return $this->getSoapClient()->$method($data);
            } catch (Exception $e) {
                $tries++;
                $this->_lastRequest = $request;
                $this->_lastException = new Bronto_Api_Exception($e->getMessage(), $e->getCode(), $e, $tries, $request);
                $this->_options
                    ->safeError()
                    ->filter(array($this, 'handleRetry'))
                    ->orElse(array($this, 'handleFallThrough'));
            }
        } while ($tries < $maxTries);
        // It should never reach here, but we'll safely terminate
        throw new Bronto_Api_Exception("Max attempts have been reached.");
    }

    /**
     * Self anonymous function to notify observer of login
     *
     * @param Bronto_Api_Observer $observer
     * @return void
     */
    public function handleLogin($observer)
    {
        $observer->onLogin($this->_token, $this->_sessionId);
    }

    /**
     * Self anonymous function for performin the retry
     *
     * @param Bronto_Api_Strategy_Error $error
     * @return boolean
     */
    public function handleRetry($error)
    {
        // Filter on a recoverable strategy
        return $error->recover($this->_lastException, $this, $this->_lastRequest);
    }

    /**
     * Handles the fallthrough cases, and notifies available classes
     *
     * @throws Bronto_Api_Exception
     */
    public function handleFallThrough()
    {
        // A write failed due to network reasons... store it
        if ($this->_lastRequest->hasUpdates() && $this->_lastException->isNetworkRelated()) {
            $this->_options->safeRetryer()->each(array($this, 'handleRetryer'));
        }
        $this->_options->safeObserver()->each(array($this, 'handleOnError'));
        throw $this->_lastException;
    }

    /**
     * Notifies the retryer to store the last request
     *
     * @param Bronto_Api_Strategy_Error $retryer
     * @return void
     */
    public function handleRetryer($retryer)
    {
        $retryer->store($this->_lastRequest, $this->getToken());
    }

    /**
     * Notifies the observer about the last exception
     *
     * @param Bronto_Api_Observer $observer
     * @return void
     */
    public function handleOnError($observer)
    {
        $observer->onError($this, $this->_lastException);
    }

    /**
     * Uses internal options to instantiate the SoapClient
     *
     * @return SoapClient
     */
    public function handleSoapClient()
    {
        $soapClass = $this->_options->getSoapClass();
        return new $soapClass($this->_options->getWsdl(), $this->_options->getSoapOptions());
    }

    /**
     * To be used solely as a convenience to $api->transfer('Object')
     *
     * @param string $name
     * @param array $arguments
     * @return Bronto_Api_Operation
     */
    public function __call($name, $arguments)
    {
        if (preg_match('/^transfer(.*)/', $name, $match)) {
            return $this->transfer($match[1]);
        }
        throw new BadMethodCallException("Method {$name} does not exist.");
    }

    /**
     * Create an operation object that wraps all CRUD requests
     *
     * @param string $object
     * @param array $methods (Optional)
     * @return Bronto_Api_Operation
     */
    public function transfer($object, array $methods = null)
    {
        $tempClass = "Bronto_Api_Operation_{$object}";
        // Note: This snippet was generated with legacy conversion
        if (is_string($tempClass) && !class_exists($tempClass, false) && !array_key_exists($tempClass, Bronto_ImportManager::$_fileCache)) {
            $dir = preg_replace('|' . str_replace("_", "/", "Bronto") . '$|', '', dirname(__FILE__));
            $file = $dir . str_replace("_", "/", $tempClass) . '.php';
            if (file_exists($file)) {
                require_once $file;
                Bronto_ImportManager::$_fileCache[$tempClass] = true;
            } else {
                Bronto_ImportManager::$_fileCache[$tempClass] = false;
            }
        }
        // End Conversion Snippet
        if ((class_exists($tempClass, false) || Bronto_ImportManager::$_fileCache[$tempClass])) {
            return new $tempClass($this);
        }
        return new Bronto_Api_Operation($this, $object, $methods);
    }

    /**
     * @return Bronto_Api_Options
     */
    public function getOptions()
    {
        return $this->_options;
    }

    /**
     * @return boolean
     */
    public function isAuthenticated()
    {
        return $this->_authenticated;
    }

    /**
     * If trace is flagged, will return the last SOAP request
     *
     * @return string
     */
    public function getLastRequest()
    {
        return $this->getSoapClient()->__getLastRequest();
    }

    /**
     * If trace is flagged, will return the last headers sent
     *
     * @return string
     */
    public function getLastRequestHeaders()
    {
        return $this->getSoapClient()->__getLastRequestHeaders();
    }

    /**
     * If trace is flagged, will return the last raw response
     *
     * @return string
     */
    public function getLastResponse()
    {
        return $this->getSoapClient()->__getLastResponse();
    }

    /**
     * If trace is flagged, will return the last response headers
     *
     * @return string
     */
    public function getLastResponseHeaders()
    {
        return $this->getSoapClient()->__getLastResponseHeaders();
    }

    /**
     * Retrieves the last exception generated from the last request
     *
     * @return Bronto_Api_Exception
     */
    public function getLastException()
    {
        return $this->_lastException;
    }

    /**
     * APIv4 token used
     *
     * @return string
     */
    public function getToken()
    {
        return $this->_token;
    }

    /**
     * Gets or creates the underlying SoapClient used to make calls
     *
     * @return SoapClient
     */
    public function getSoapClient()
    {
        if (is_null($this->_soapClient)) {
            $soapClient = $this->_options->safeSoapClient()->orElse(array($this, 'handleSoapClient'));
            $this->_soapClient = $soapClient->get();
        }
        return $this->_soapClient;
    }

    /**
     * Fields necesary to deserialize the API wrapper
     *
     * @return array
     */
    public function __sleep()
    {
        return array('_token', '_options');
    }
}
